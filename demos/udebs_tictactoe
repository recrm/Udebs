#!/usr/bin/env python3
import udebs
import json
from udebs.treesearch import BruteForce

game_config = """
<udebs>

<config>
    <logging>False</logging>
    <name>tictactoe</name>
    <immutable>True</immutable>
</config>

<map>
    <dim>
        <x>3</x>
        <y>3</y>
    </dim>
</map>

<definitions>
    <stats>
        <ACT />
    </stats>
    <strings>
        <token />
    </strings>
</definitions>

<entities>
    <player />

    <tick>
        <require>
            <i>score = (ENDSTATE)</i>
            <i>$score != None</i>
        </require>
        <effect>EXIT $score</effect>
    </tick>

    <xPlayer immutable="False">
        <group>player</group>
        <ACT>2</ACT>
        <token>x</token>
    </xPlayer>

    <oPlayer immutable="False">
        <group>player</group>
        <ACT>1</ACT>
        <token>o</token>
    </oPlayer>

    <x />
    <o />

    <placement>
        <require>
            <i>$caster.STAT.ACT &gt;= 2</i>
            <i>$target.NAME == empty</i>
        </require>
        <effect>
            <i>$caster.STAT.token RECRUIT $target</i>
            <i>$caster ACT -= 2</i>
            <i>ALL.player ACT += 1</i>
        </effect>
    </placement>

</entities>
</udebs>
"""

# Setup Udebs
@udebs.register(["self"])
def ENDSTATE(state):
    def rows(gameMap):
        """Iterate over possible win conditions in game map."""
        size = len(gameMap)

        for i in range(size):
            yield gameMap[i]
            yield [j[i] for j in gameMap]

        yield [gameMap[i][i] for i in range(size)]
        yield [gameMap[size - 1 - i][i] for i in range(size)]

    # Check for a win
    tie = True
    for i in rows(state.map["map"].map):
        value = set(i)
        if "empty" in value:
            tie = False
        elif len(value) == 1:
            if i[0] == "x":
                return 1
            elif i[0] == "o":
                return -1

    if tie:
        return 0

class TicTacToe(BruteForce):
    def legalMoves(self):
        """Create a list of legal moves in current state space."""
        player = "xPlayer" if self.getStat("xPlayer", "ACT") == 2 else "oPlayer"
        for loc, value in self.map["map"].items():
            if value == "empty":
                yield player, loc, "placement"

    def pState(self):
        """Return an immutable representation of a game map."""
        def rotate(matrix):
            return tuple(zip(*matrix[::-1]))

        def flip(matrix):
            return tuple(reversed(matrix))

        value = self.map["map"].map

        symetries = [tuple(tuple(i) for i in value)]
        symetries.append(flip(symetries[0]))

        for i in range(6):
            symetries.append(rotate(symetries[-2]))

        return frozenset(symetries)

    def tree(self, debug=True):
        """Compile all results into a tree."""
        # If node is solvable return solution
        if int(self.result()) != 0:
            return self.result()

        # Collect all possible outputs
        completed = set()
        storage = {}
        for substate, entry in self.substates():
            if substate.pState() not in completed:
                completed.add(substate.pState())
                subresult = substate.tree(debug=False)

                # Remove any options that don't block oponents autowin.
                if not isinstance(subresult, dict):
                    if subresult.turns == 1:
                        continue

                storage[entryName(entry)] = subresult

        # Flatten inevitable ties
        for k, v in storage.items():
            if isinstance(v, dict) or int(v) != 0:
                return storage
        else:
            return self.result()

def entryName(entry):
    if entry is not None:
        player, (x, y, _), _ = entry
        return player[0] + "_" + str(x) + "_" + str(y)

    return "root"

def deserialize(node):
    if isinstance(node, dict):
        return {k:deserialize(v) for k,v in node.items()}
    return int(node)

if __name__ == "__main__":
    # Create state analysis engine
    game = udebs.battleStart(game_config, field=TicTacToe())
    with udebs.Timer():
        final = game.result()

    print("final", final.value, final.turns)
    print("states checked", len(game.storage))

    tree = deserialize(game.tree())

    # Save tree
    with open("tictactoe.json", "w+") as f:
        json.dump(tree, f)
